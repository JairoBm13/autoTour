/*
 * generated by Xtext 2.10.0
 */
package co.edu.uniandes.serializer;

import co.edu.uniandes.services.ToursdslGrammarAccess;
import com.google.inject.Inject;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.IGrammarAccess;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.serializer.analysis.GrammarAlias.AbstractElementAlias;
import org.eclipse.xtext.serializer.analysis.ISyntacticSequencerPDAProvider.ISynTransition;
import org.eclipse.xtext.serializer.sequencer.AbstractSyntacticSequencer;

@SuppressWarnings("all")
public class ToursdslSyntacticSequencer extends AbstractSyntacticSequencer {

	protected ToursdslGrammarAccess grammarAccess;
	
	@Inject
	protected void init(IGrammarAccess access) {
		grammarAccess = (ToursdslGrammarAccess) access;
	}
	
	@Override
	protected String getUnassignedRuleCallToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (ruleCall.getRule() == grammarAccess.getCLOSING_CURLY_BRACKETRule())
			return getCLOSING_CURLY_BRACKETToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCLOSING_SQUARE_BRACKETRule())
			return getCLOSING_SQUARE_BRACKETToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOLONRule())
			return getCOLONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOMMARule())
			return getCOMMAToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOORDINATE_XRule())
			return getCOORDINATE_XToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOORDINATE_YRule())
			return getCOORDINATE_YToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getCOORDINATE_ZRule())
			return getCOORDINATE_ZToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDESCRIPTIONRule())
			return getDESCRIPTIONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getDOTRule())
			return getDOTToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getFROMRule())
			return getFROMToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getINTRule())
			return getINTToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getNAMERule())
			return getNAMEToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOPENING_CURLY_BRACKETRule())
			return getOPENING_CURLY_BRACKETToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getOPENING_SQUARE_BRACKETRule())
			return getOPENING_SQUARE_BRACKETToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPATHSRule())
			return getPATHSToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPLACESRule())
			return getPLACESToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getPOSITIONRule())
			return getPOSITIONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getROTATIONRule())
			return getROTATIONToken(semanticObject, ruleCall, node);
		else if (ruleCall.getRule() == grammarAccess.getTORule())
			return getTOToken(semanticObject, ruleCall, node);
		return "";
	}
	
	/**
	 * terminal CLOSING_CURLY_BRACKET:
	 * 
	 * '}';
	 */
	protected String getCLOSING_CURLY_BRACKETToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "}";
	}
	
	/**
	 * terminal CLOSING_SQUARE_BRACKET:
	 * 
	 * ']';
	 */
	protected String getCLOSING_SQUARE_BRACKETToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "]";
	}
	
	/**
	 * terminal COLON:
	 * 
	 * ':';
	 */
	protected String getCOLONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ":";
	}
	
	/**
	 * terminal COMMA:
	 * 	
	 * ',';
	 */
	protected String getCOMMAToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ",";
	}
	
	/**
	 * terminal COORDINATE_X:
	 * 
	 * 'x';
	 */
	protected String getCOORDINATE_XToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "x";
	}
	
	/**
	 * terminal COORDINATE_Y:
	 * 
	 * 'y';
	 */
	protected String getCOORDINATE_YToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "y";
	}
	
	/**
	 * terminal COORDINATE_Z:
	 * 
	 * 'z';
	 */
	protected String getCOORDINATE_ZToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "z";
	}
	
	/**
	 * terminal DESCRIPTION:
	 * 
	 * 'description';
	 */
	protected String getDESCRIPTIONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "description";
	}
	
	/**
	 * terminal DOT:
	 * 	
	 * '.';
	 */
	protected String getDOTToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return ".";
	}
	
	/**
	 * terminal FROM:
	 * 
	 * 'from';
	 */
	protected String getFROMToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "from";
	}
	
	/**
	 * terminal INT returns ecore::EInt: ('0'..'9')+;
	 */
	protected String getINTToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "";
	}
	
	/**
	 * terminal NAME:
	 * 	
	 * 'name';
	 */
	protected String getNAMEToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "name";
	}
	
	/**
	 * terminal OPENING_CURLY_BRACKET:
	 * 
	 * '{';
	 */
	protected String getOPENING_CURLY_BRACKETToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "{";
	}
	
	/**
	 * terminal OPENING_SQUARE_BRACKET:
	 * 	
	 * '[';
	 */
	protected String getOPENING_SQUARE_BRACKETToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "[";
	}
	
	/**
	 * terminal PATHS:
	 * 'paths';
	 */
	protected String getPATHSToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "paths";
	}
	
	/**
	 * terminal PLACES:
	 * 
	 * 'places';
	 */
	protected String getPLACESToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "places";
	}
	
	/**
	 * terminal POSITION:
	 * 
	 * 'position';
	 */
	protected String getPOSITIONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "position";
	}
	
	/**
	 * terminal ROTATION:
	 * 
	 * 'rotation';
	 */
	protected String getROTATIONToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "rotation";
	}
	
	/**
	 * terminal TO:
	 * 
	 * 'to';
	 */
	protected String getTOToken(EObject semanticObject, RuleCall ruleCall, INode node) {
		if (node != null)
			return getTokenText(node);
		return "to";
	}
	
	@Override
	protected void emitUnassignedTokens(EObject semanticObject, ISynTransition transition, INode fromNode, INode toNode) {
		if (transition.getAmbiguousSyntaxes().isEmpty()) return;
		List<INode> transitionNodes = collectNodes(fromNode, toNode);
		for (AbstractElementAlias syntax : transition.getAmbiguousSyntaxes()) {
			List<INode> syntaxNodes = getNodesFor(transitionNodes, syntax);
			acceptNodes(getLastNavigableState(), syntaxNodes);
		}
	}

}
